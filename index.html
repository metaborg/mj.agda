<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Readme</title><link rel="stylesheet" href="Agda.css"></head><body><pre><a id="1" class="Comment">{-
  This is the readme of the Agda mechanization accompanying our
  POPL 2018 paper:

    &quot;Intrinsically-Typed Interpreters for Imperative Languages&quot;

  The repository is hosted here:
  - https://github.com/metaborg/mj.agda

  A rendered and linked version of this readme can be found here:
  - https://metaborg.github.io/mj.agda/

  This development has been tested against Agda 2.5.3.  If you have
  this installed you should be able simply run `make` in the project
  root, which will checkout some libraries in `./lib/` first and then
  build `./Readme.agda` which serves as the main entrypoint to the
  development.

  Alternatively you can run `make docs` to build the html version of
  the development which is useful if you want to navigate the code
  (starting e.g. in `docs/index.html`) without having an editor setup
  for it. The html docs are syntax-highlighted and you can click
  references to navigate to their definitions.

  There are some minor differences between the Agda code used in the
  paper and this mechanization.  One general (but minor) discrepancy
  is that the definitions in the paper are typed in a manner that is
  not universe polymorphic.  However, the development makes extensive
  use of universe polymorphism, by explicitly quantifying over
  universe levels (e.g., `i` in `{i} → Set i`).

  Other discrepancies are summarized below in this readme.
-}</a>

<a id="1395" class="Keyword">module</a> <a id="1402" href="Readme.html" class="Module">Readme</a> <a id="1409" class="Keyword">where</a>

<a id="1416" class="Comment">{-
  * Section 2 *

  We develop a monadic, well-typed interpreter for STLC and interpret
  a few example programs.

  Unlike the interpreter summarized in the paper, the STLC semantics
  in the development makes use of integers and integer operations.
-}</a>
<a id="1672" class="Keyword">open</a> <a id="1677" class="Keyword">import</a> <a id="1684" href="STLC.Semantics.html" class="Module">STLC.Semantics</a>
<a id="1699" class="Keyword">open</a> <a id="1704" class="Keyword">import</a> <a id="1711" href="STLC.Examples.html" class="Module">STLC.Examples</a>

<a id="1726" class="Comment">{-
  * Section 3.1 - 3.3 *

  We demonstrate how naively extending the approach to cover
  imperative state is possible, but requires explicit weakening of
  bound values in the interpreter.
-}</a>

<a id="1921" class="Keyword">open</a> <a id="1926" class="Keyword">import</a> <a id="1933" href="STLCRef.SemanticsLB.html" class="Module">STLCRef.SemanticsLB</a>

<a id="1954" class="Comment">{-
  * Section 3.4 : dependent passing style *

  We can improve the semantics with a form of monadic strength to get
  rid of explicit weakening.
-}</a>
<a id="2104" class="Keyword">open</a> <a id="2109" class="Keyword">import</a> <a id="2116" href="STLCRef.Semantics.html" class="Module">STLCRef.Semantics</a>
<a id="2134" class="Keyword">open</a> <a id="2139" class="Keyword">import</a> <a id="2146" href="STLCRef.Examples.html" class="Module">STLCRef.Examples</a>

<a id="2164" class="Comment">{-
  * Section 4 until 4.3 *

  We implement the scopes and frames approach in the following small
  Agda library.
-}</a>

<a id="2283" class="Keyword">open</a> <a id="2288" class="Keyword">import</a> <a id="2295" href="ScopesFrames.ScopesFrames.html" class="Module">ScopesFrames.ScopesFrames</a>

<a id="2322" class="Comment">{-
  * Section 4.4 *

  We demonstrate the basic usage of this library on an interpreter for
  STLC using scopes and frames.
-}</a>
<a id="2450" class="Keyword">open</a> <a id="2455" class="Keyword">import</a> <a id="2462" href="STLCSF.Semantics.html" class="Module">STLCSF.Semantics</a>

<a id="2480" class="Comment">{-
  * Section 5 *

  We show how our techniques scale by defining an intrinsically-typed
  interpreter for Middleweight Java (MJ), a language with:

  - Imperative objects
  - Sub-typing
  - Mutable, block-scoped environments
  - Early returns

  The only discrepancy between the code in this development and the
  code shown in the paper is the following:

  - Pattern matching lambdas are not useful for pattern matching
    against.  Instead of using `All` types with pattern matching
    lambdas (Section 5.3 and 5.4), we use tagging predicates in
    `MJSF.Syntax`.

  Then there are a few notable differences between the original
  presentation of MJ and our development:

  - Original MJ distinguishes promotable expressions (method
    invocation and object creation) and all other expressions. We
    admit arbitrary expressions to be promoted. This does not change
    the semantics in any significant way. The expressions that we
    allow to be promoted are side-effect free.

  - returns are implemented by modeling non-void methods as having an
    expression as its last statement (technically, this is enforced by
    the type rules of Original MJ; in our development it is
    syntactically enforced).

  - MJ only has equality comparison expressions that can be used as
    conditional expressions.  We allow arbitrary expressions, and use
    if-zero (`ifz`) for conditionals.  This does not correspond to MJ
    or Java, but it would be straightforward to add Booleans and use a
    more conventional `if` statement instead.

  - If-zero statements have ordinary statements as their
    sub-statements.  These can either be block statements or any other
    statement which does not allocate a new frame.  In Original MJ, if
    statements must be blocks.

  - We include integers and integer operations, which are not in
    Original MJ.

  - Our MJ syntax admits fields typed by `void`, which Original MJ
    does not.

-}</a>

<a id="4427" class="Keyword">open</a> <a id="4432" class="Keyword">import</a> <a id="4439" href="MJSF.Syntax.html" class="Module">MJSF.Syntax</a>
<a id="4451" class="Keyword">open</a> <a id="4456" class="Keyword">import</a> <a id="4463" href="MJSF.Values.html" class="Module">MJSF.Values</a>
<a id="4475" class="Keyword">open</a> <a id="4480" class="Keyword">import</a> <a id="4487" href="MJSF.Monad.html" class="Module">MJSF.Monad</a>
<a id="4498" class="Keyword">open</a> <a id="4503" class="Keyword">import</a> <a id="4510" href="MJSF.Semantics.html" class="Module">MJSF.Semantics</a>

<a id="4526" class="Comment">{-
  We demonstrate that our interpreter is executable:
-}</a>
<a id="4585" class="Keyword">open</a> <a id="4590" class="Keyword">import</a> <a id="4597" href="MJSF.Examples.Integer.html" class="Module">MJSF.Examples.Integer</a>
<a id="4619" class="Keyword">open</a> <a id="4624" class="Keyword">import</a> <a id="4631" href="MJSF.Examples.DynamicDispatch.html" class="Module">MJSF.Examples.DynamicDispatch</a>


<a id="4663" class="Comment">{-
  * Appendix A *

  The following code artifacts *are not* described in the paper, but
  are used as a comparison point to evaluate the impact on the
  interpreter of using the scopes and frames model of binding.

  This is an intrinsically-typed interpreter for MJ without the use of
  scope-and-frames. Instead it describes a language-*dependent*
  classtable construction to deal with object dot-access binding and
  typing contexts and environments to deal with lexical binding
  respectively.
-}</a>
<a id="5167" class="Keyword">open</a> <a id="5172" class="Keyword">import</a> <a id="5179" href="MJ.Syntax.Typed.html" class="Module">MJ.Syntax.Typed</a>

<a id="5196" class="Comment">-- lexical contexts</a>
<a id="5216" class="Keyword">open</a> <a id="5221" class="Keyword">import</a> <a id="5228" href="MJ.LexicalScope.html" class="Module">MJ.LexicalScope</a>

<a id="5245" class="Comment">-- class table</a>
<a id="5260" class="Keyword">open</a> <a id="5265" class="Keyword">import</a> <a id="5272" href="MJ.Classtable.Core.html" class="Module">MJ.Classtable.Core</a>
<a id="5291" class="Keyword">open</a> <a id="5296" class="Keyword">import</a> <a id="5303" href="MJ.Classtable.Membership.html" class="Module">MJ.Classtable.Membership</a>
<a id="5328" class="Keyword">open</a> <a id="5333" class="Keyword">import</a> <a id="5340" href="MJ.Classtable.Code.html" class="Module">MJ.Classtable.Code</a>

<a id="5360" class="Comment">-- semantics</a>
<a id="5373" class="Keyword">open</a> <a id="5378" class="Keyword">import</a> <a id="5385" href="MJ.Semantics.Values.html" class="Module">MJ.Semantics.Values</a>
<a id="5405" class="Keyword">open</a> <a id="5410" class="Keyword">import</a> <a id="5417" href="MJ.Semantics.Objects.Flat.html" class="Module">MJ.Semantics.Objects.Flat</a>
<a id="5443" class="Keyword">open</a> <a id="5448" class="Keyword">import</a> <a id="5455" href="MJ.Semantics.Monadic.html" class="Module">MJ.Semantics.Monadic</a>

<a id="5477" class="Comment">-- examples</a>
<a id="5489" class="Keyword">open</a> <a id="5494" class="Keyword">import</a> <a id="5501" href="MJ.Examples.Integer.html" class="Module">MJ.Examples.Integer</a>
<a id="5521" class="Keyword">open</a> <a id="5526" class="Keyword">import</a> <a id="5533" href="MJ.Examples.Exceptions.html" class="Module">MJ.Examples.Exceptions</a>
<a id="5556" class="Keyword">open</a> <a id="5561" class="Keyword">import</a> <a id="5568" href="MJ.Examples.While.html" class="Module">MJ.Examples.While</a>
<a id="5586" class="Keyword">open</a> <a id="5591" class="Keyword">import</a> <a id="5598" href="MJ.Examples.DynDispatch.html" class="Module">MJ.Examples.DynDispatch</a>

<a id="5623" class="Comment">{-
  * Appendix B *

  Additionally we demonstrate briefly how Agda&#39;s typeclass mechanism
  is not sufficiently strong to infer store extension facts for
  weakening. (Notably Idris rejects an equivalent program as well
  because the two instances are overlapping)
-}</a>
<a id="5891" class="Keyword">open</a> <a id="5896" class="Keyword">import</a> <a id="5903" href="Experiments.Infer.html" class="Module">Experiments.Infer</a>

<a id="5922" class="Comment">{-
  * Appendix C *

  Our interpreters make use of the operator `_^_` operator, defined
  as:

  (1) `_^_ : ∀ {Σ Γ}{p q : List Type → Set} ⦃ w : Weakenable q ⦄ →
             M Γ p Σ → q Σ → M Γ (p ⊗ q) Σ`

  This operator is strikingly similar to the strength operator that is
  characteristic of strong monads:

  (2)  `_^_ : ∀ {p q} → M p → q → M (p ⊗ q)`

  Here, `p` and `q` are objects in a category ℂ, and M is a monad for
  ℂ.

  In the following development we show how to define a monad that is
  morally equivalent to ours.  The monad in the development below is
  defined over the category of monotone predicates.  In this category,
  the store-passing monad is a strong monad, with the usual notion of
  monadic strength, i.e., (2) above.

  We also show how, in this category, we can write an interpreter
  without explicit weakening, by writing the interpreter in a
  point-free style.
-}</a>

<a id="6828" class="Keyword">open</a> <a id="6833" class="Keyword">import</a> <a id="6840" href="Experiments.Category.html" class="Module">Experiments.Category</a>
<a id="6861" class="Keyword">open</a> <a id="6866" class="Keyword">import</a> <a id="6873" href="Experiments.StrongMonad.html" class="Module">Experiments.StrongMonad</a>
<a id="6897" class="Keyword">open</a> <a id="6902" class="Keyword">import</a> <a id="6909" href="Experiments.STLCRefPointfree.html" class="Module">Experiments.STLCRefPointfree</a>

<a id="6939" class="Comment">{-
  We briefly outline how these experiments relate to our paper.

  The interpreters in our paper are defined in terms of ordinary Agda
  functions and indexed types.  Agda functions and indexed types are
  not guaranteed to be weakenable, and Agda does not have built-in
  support for automatically weakening types across monadic binds.  In
  our paper, we address the weakening problem by making explicit use
  in our interpreters of the `_^_` operator, which is morally
  equivalent to the monadic strength operator for monotone predicates
  over store types, defined in the categorical development above.  Our
  `_^_` operator explicitly requires `q` to be weakenable, which is a
  fairly minimal requirement for convincing Agda&#39;s type checker that
  carrying types over monadic binds is safe.

  The categorical model enjoys a cleaner treatment of weakening, but
  it is more cumbersome to write interpreters in Agda using this
  model, because of the additional level of encoding imposed by
  constructing and working with objects and morphisms in a category,
  as encoded in Agda.  However, we imagine that the categorical
  development is a good target model for a future specification
  language for dynamic semantics.
-}</a>
</pre></body></html>